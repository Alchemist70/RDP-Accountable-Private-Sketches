#!/usr/bin/env python3
"""
Populate a LaTeX table from aggregated RDP JSON produced by
`scripts/aggregate_rdp_smokegrid.py` -> `paper_figures/rdp_smokegrid_demo.json`.
Writes `paper_figures/rdp_table.tex` which can be \input into the main tex.

Usage:
  python scripts/populate_rdp_table.py --json paper_figures/rdp_smokegrid_demo.json

If the JSON is missing or malformed, the script will write a small placeholder
LaTeX table and exit non-zero.
"""
from __future__ import annotations
import json
import argparse
from pathlib import Path
import sys


def read_json(path: Path):
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def make_table_rows(records):
    # Expect records to be a list of dicts with keys: run, q, sigma, steps, eps
    rows = []
    for rec in records:
        run = rec.get("run", rec.get("name", "unknown"))
        q = rec.get("q", rec.get("sampling_rate", "-"))
        sigma = rec.get("sigma", rec.get("std", "-"))
        steps = rec.get("steps", rec.get("T", "-"))
        eps = rec.get("epsilon", rec.get("eps", rec.get("varepsilon", "-")))
        rows.append((run, q, sigma, steps, eps))
    return rows


def write_tex_table(outpath: Path, rows):
    outpath.parent.mkdir(parents=True, exist_ok=True)
    with outpath.open("w", encoding="utf-8") as f:
        f.write("% Auto-generated by scripts/populate_rdp_table.py\n")
        f.write("\\begin{table}[ht]\n")
        f.write("  \\centering\n")
        f.write("  \\caption{Aggregated RDP smoke-grid outputs.}\n")
        f.write("  \\label{tab:rdp-smoke}\n")
        f.write("  \\begin{tabular}{lrrrr}\n")
        f.write("    \\toprule\n")
        f.write("    Run & sampling $q$ & $\\sigma$ & steps & $\\varepsilon$ ($\\delta=10^{-6}$) \\\\ \n")
        f.write("    \\midrule\n")
        for run, q, sigma, steps, eps in rows:
            f.write(f"    {run} & {q} & {sigma} & {steps} & {eps} \\\\ \n")
        f.write("    \\bottomrule\n")
        f.write("  \\end{tabular}\n")
        f.write("\\end{table}\n")


def main(argv=None):
    p = argparse.ArgumentParser()
    p.add_argument("--json", type=Path, default=Path("paper_figures/rdp_smokegrid_demo.json"), help="Aggregated RDP JSON input")
    p.add_argument("--out", type=Path, default=Path("paper_figures/rdp_table.tex"), help="Output tex file")
    args = p.parse_args(argv)

    if not args.json.exists():
        print(f"ERROR: Input JSON {args.json} not found.", file=sys.stderr)
        # write a placeholder table so LaTeX compiles
        write_tex_table(args.out, [("demo-missing", "-", "-", "-", "-")])
        sys.exit(2)

    try:
        data = read_json(args.json)
    except Exception as e:
        print(f"ERROR: Could not read JSON: {e}", file=sys.stderr)
        write_tex_table(args.out, [("demo-badjson", "-", "-", "-", "-")])
        sys.exit(3)

    # Data might be either a dict with 'runs' or a list
    if isinstance(data, dict) and "runs" in data:
        records = data["runs"]
    elif isinstance(data, list):
        records = data
    elif isinstance(data, dict):
        # try to infer entries by scanning values
        records = []
        for k, v in data.items():
            if isinstance(v, dict) and any(x in v for x in ("sigma", "epsilon", "eps", "q")):
                rec = v.copy()
                rec.setdefault("run", k)
                records.append(rec)
    else:
        records = []

    rows = make_table_rows(records)
    write_tex_table(args.out, rows)
    print(f"Wrote LaTeX table to {args.out}")


if __name__ == "__main__":
    main()
